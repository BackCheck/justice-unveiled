/**
 * Court Dossier Validation Engine
 * Section validation, annexure integrity, citation control, and court readiness scoring.
 */

import type { CourtProfile, CourtId, CourtFilingTemplate } from '@/types/reports';
import { COURT_PROFILES, COURT_FILING_TEMPLATES } from './courtProfiles';
import type { DossierSection, DossierAnnexure } from '@/components/reports/DossierBuilder';

// ── Types ──

export interface ValidationResult {
  isValid: boolean;
  score: number; // 0-100
  issues: ValidationIssue[];
  breakdown: ReadinessBreakdown;
}

export interface ValidationIssue {
  type: 'error' | 'warning' | 'info';
  category: 'section' | 'annexure' | 'citation' | 'party' | 'content';
  message: string;
}

export interface ReadinessBreakdown {
  requiredSections: { score: number; total: number; present: number };
  contentDensity: { score: number; filledSections: number; totalSections: number; underThreshold: number };
  annexureIntegrity: { score: number; issues: string[] };
  partyDetails: { score: number; hasPetitioner: boolean; hasRespondent: boolean };
  verificationPresent: { score: number; present: boolean };
}

const MIN_SECTION_WORDS = 30;

// ── Main Validator ──

export function validateCourtDossier(
  sections: DossierSection[],
  annexures: DossierAnnexure[],
  courtId: CourtId,
  filingTemplate: CourtFilingTemplate,
  petitionerName?: string,
  respondentName?: string,
): ValidationResult {
  const court = COURT_PROFILES[courtId];
  const template = COURT_FILING_TEMPLATES[filingTemplate];
  const issues: ValidationIssue[] = [];

  // 1. Required Section Validation
  const requiredSectionTypes = court.requiredSections;
  const templateSectionTypes = template.sections.filter(s => s.required).map(s => s.type);
  const sectionTitlesLower = sections.map(s => s.title.toLowerCase());

  const sectionTypeMapping: Record<string, string[]> = {
    cover: ['cover', 'title'],
    parties: ['parties', 'party', 'petitioner', 'respondent', 'complainant'],
    facts: ['facts', 'statement of facts', 'fir details'],
    questions: ['questions', 'questions of law', 'issues'],
    grounds: ['grounds', 'legal basis', 'violations'],
    arguments: ['arguments', 'submissions'],
    prayer: ['prayer', 'relief', 'relief sought'],
    verification: ['verification', 'affidavit'],
    index: ['index'],
    annexures: ['annexures', 'annexure'],
    synopsis: ['synopsis', 'list of dates'],
    interimRelief: ['interim relief', 'interim'],
    maintainability: ['maintainability', 'jurisdiction'],
    precedents: ['precedents', 'relied upon'],
  };

  const matchesSection = (type: string): boolean => {
    const keywords = sectionTypeMapping[type] || [type.toLowerCase()];
    return sectionTitlesLower.some(title => keywords.some(kw => title.includes(kw)));
  };

  // Check required sections from court profile (excluding cover/index/annexures which are auto-generated)
  const autoGenerated = ['cover', 'index', 'annexures', 'verification'];
  const checkableSections = templateSectionTypes.filter(t => !autoGenerated.includes(t));
  let requiredPresent = 0;
  const requiredTotal = checkableSections.length;

  checkableSections.forEach(type => {
    if (matchesSection(type)) {
      requiredPresent++;
    } else {
      issues.push({
        type: 'error',
        category: 'section',
        message: `Required section missing: "${type}" (expected by ${court.name})`,
      });
    }
  });

  const requiredScore = requiredTotal > 0 ? Math.round((requiredPresent / requiredTotal) * 100) : 100;

  // 2. Content Density Validation
  const filledSections = sections.filter(s => s.content.trim().length > 0);
  const underThreshold = sections.filter(s => {
    const words = s.content.trim().split(/\s+/).filter(Boolean).length;
    return words > 0 && words < MIN_SECTION_WORDS;
  });

  underThreshold.forEach(s => {
    const words = s.content.trim().split(/\s+/).filter(Boolean).length;
    issues.push({
      type: 'warning',
      category: 'content',
      message: `"${s.title}" has only ${words} words (minimum recommended: ${MIN_SECTION_WORDS})`,
    });
  });

  const emptySections = sections.filter(s => !s.content.trim());
  emptySections.forEach(s => {
    issues.push({
      type: 'warning',
      category: 'content',
      message: `"${s.title}" is empty — courts may reject sections without content`,
    });
  });

  const contentScore = sections.length > 0
    ? Math.round((filledSections.length / sections.length) * 100)
    : 0;

  // 3. Annexure Integrity Validation
  const selectedAnnexures = annexures.filter(a => a.selected);
  const annexIssues: string[] = [];

  // Check for empty annex titles
  selectedAnnexures.forEach((a, i) => {
    if (!a.label || a.label.trim() === '') {
      annexIssues.push(`Annexure ${String.fromCharCode(65 + i)} has no title`);
      issues.push({ type: 'error', category: 'annexure', message: `Annexure ${String.fromCharCode(65 + i)} has an empty title` });
    }
  });

  // Check body references to annexures
  const allContent = sections.map(s => s.content).join(' ').toLowerCase();
  selectedAnnexures.forEach((a, i) => {
    const letter = String.fromCharCode(65 + i);
    const possibleRefs = [
      `annex-${letter}`.toLowerCase(),
      `annexure-${letter}`.toLowerCase(),
      `annex ${letter}`.toLowerCase(),
      `annexure ${letter}`.toLowerCase(),
      `exhibit-${letter}`.toLowerCase(),
      `(annex-${letter})`.toLowerCase(),
      `(annexure-${letter})`.toLowerCase(),
    ];
    const referenced = possibleRefs.some(ref => allContent.includes(ref));
    if (!referenced) {
      annexIssues.push(`${court.filingStyle.annexLabel.replace(/[A-Z0-9]$/, '')}${letter} not referenced in body text`);
      issues.push({
        type: 'warning',
        category: 'annexure',
        message: `Annexure "${a.label}" (${letter}) is not referenced in any section body`,
      });
    }
  });

  const annexScore = selectedAnnexures.length > 0
    ? Math.max(0, 100 - (annexIssues.length * 20))
    : 100;

  // 4. Party Details
  const hasPetitioner = !!petitionerName?.trim();
  const hasRespondent = !!respondentName?.trim();
  if (!hasPetitioner) {
    issues.push({ type: 'warning', category: 'party', message: 'Petitioner name is not provided' });
  }
  if (!hasRespondent) {
    issues.push({ type: 'warning', category: 'party', message: 'Respondent name is not provided' });
  }
  const partyScore = (hasPetitioner ? 50 : 0) + (hasRespondent ? 50 : 0);

  // 5. Verification present
  const hasVerification = true; // Auto-generated by court dossier generator
  const verificationScore = hasVerification ? 100 : 0;

  // Overall score (weighted)
  const overallScore = Math.round(
    requiredScore * 0.30 +
    contentScore * 0.30 +
    annexScore * 0.15 +
    partyScore * 0.15 +
    verificationScore * 0.10
  );

  return {
    isValid: issues.filter(i => i.type === 'error').length === 0,
    score: overallScore,
    issues,
    breakdown: {
      requiredSections: { score: requiredScore, total: requiredTotal, present: requiredPresent },
      contentDensity: { score: contentScore, filledSections: filledSections.length, totalSections: sections.length, underThreshold: underThreshold.length },
      annexureIntegrity: { score: annexScore, issues: annexIssues },
      partyDetails: { score: partyScore, hasPetitioner, hasRespondent },
      verificationPresent: { score: verificationScore, present: hasVerification },
    },
  };
}

// ── Citation Scanner ──

const KNOWN_STATUTE_PATTERNS = [
  /article\s+\d+[a-z]?\s*(of the constitution)?/gi,
  /section\s+\d+[a-z]?\s*(of\s+(the\s+)?[a-z]+)?/gi,
  /ppc\s+§?\s*\d+/gi,
  /crpc\s+§?\s*\d+/gi,
  /peca\s+\d{4}\s*(§?\s*\d+)?/gi,
];

const SUSPICIOUS_CITATION_PATTERNS = [
  /\d{4}\s+[A-Z]{2,5}\s+\d+/g,      // e.g., "2019 SCMR 123"
  /plj\s+\d{4}\s+[a-z]+\s+\d+/gi,    // e.g., "PLJ 2020 SC 45"
  /pld\s+\d{4}\s+[a-z]+\s+\d+/gi,    // e.g., "PLD 2018 Lahore 123"
];

export interface CitationAudit {
  totalCitations: number;
  statutoryRefs: string[];
  caseLawRefs: string[];
  unverifiedCount: number;
  warnings: string[];
}

export function auditCitations(
  sections: DossierSection[],
  strictMode: boolean,
  knownCitations: string[] = [],
): CitationAudit {
  const allContent = sections.map(s => s.content).join('\n');
  const warnings: string[] = [];
  const statutoryRefs: string[] = [];
  const caseLawRefs: string[] = [];

  // Extract statutory references
  KNOWN_STATUTE_PATTERNS.forEach(pattern => {
    const matches = allContent.match(pattern) || [];
    statutoryRefs.push(...matches.map(m => m.trim()));
  });

  // Extract case law references
  SUSPICIOUS_CITATION_PATTERNS.forEach(pattern => {
    const matches = allContent.match(pattern) || [];
    caseLawRefs.push(...matches.map(m => m.trim()));
  });

  // In strict mode, flag unverified case law
  let unverifiedCount = 0;
  if (strictMode && caseLawRefs.length > 0) {
    const knownLower = knownCitations.map(c => c.toLowerCase());
    caseLawRefs.forEach(cite => {
      if (!knownLower.some(k => cite.toLowerCase().includes(k))) {
        unverifiedCount++;
        warnings.push(`Unverified citation: "${cite}" — not found in database`);
      }
    });
  }

  return {
    totalCitations: statutoryRefs.length + caseLawRefs.length,
    statutoryRefs: [...new Set(statutoryRefs)],
    caseLawRefs: [...new Set(caseLawRefs)],
    unverifiedCount,
    warnings,
  };
}

// ── Readiness Label ──

export function getReadinessLabel(score: number): { label: string; color: string } {
  if (score >= 90) return { label: 'Court Ready', color: 'text-green-600' };
  if (score >= 70) return { label: 'Nearly Ready', color: 'text-amber-600' };
  if (score >= 50) return { label: 'Needs Work', color: 'text-orange-600' };
  return { label: 'Incomplete', color: 'text-destructive' };
}
